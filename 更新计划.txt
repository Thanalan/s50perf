由于原有计划使用信号量进行同步，导致只能前一个完成后才会下发下一个请求，最终测试得到性能过差，一秒钟仅能执行900次操作，远远低于预期性能。所以更改计划。
发送请求时尽量多发送，不在等待完成，函数即可返回。统计发送的数目。
接收线程需要增加定时，需要和发送线程进行同步的开始和停止，需要统计在这段时间内成功处理完成的请求数量，即是本次性能测试所完成的请求数量。统计由原本的发送函数改为接收函数。仍然为多线程模式

使用gettimeofday完成时间统计

struct completion_struct
{
    volatile int sem;
	int i;
};

/* Use semaphores to signal completion of events */
#define COMPLETION_STRUCT completion_struct

#define COMPLETION_INIT(s)  __sync_fetch_and_and (&((s)->sem), 0) ;
//sem_init(&((s)->semaphore), 0, 0);

static int COMPLETION_WAIT(struct completion_struct *s, int timeout){
	while(1){
		if(__sync_bool_compare_and_swap(&((s)->sem),1,2))
		{
			break;
		}
	}
		return 1;
}
/*
#define COMPLETION_WAIT(s, timeout) \
	while(1){\
		if(__sync_bool_compare_and_swap(&((s)->sem),0,1){\
			break;}\
		};
*/
#define COMPLETE(s) __sync_fetch_and_add (&((s)->sem),1); 

#define COMPLETION_DESTROY(s)  __sync_fetch_and_and (&((s)->sem), 0);